"use strict";(self["webpackChunkruiyang_zhou_website"]=self["webpackChunkruiyang_zhou_website"]||[]).push([[829],{4381:function(e,t,a){a.r(t),a.d(t,{default:function(){return v}});var i=a(6768),o=a.p+"img/flowdiagram.8df90239.png",s=a.p+"img/signal.fb83bce9.png",n=a.p+"img/lindley.d710d6a6.png",r=a.p+"img/distortionalgo.561d482a.png",l=a.p+"img/code.563ca0ed.png",d=a.p+"img/GUI.866dc6a9.png",h=a.p+"media/music_before_distortion.ce1bd533.wav",c=a.p+"media/music_after_distortion.1d1a678a.wav";const u=(0,i.Fv)('<div data-v-022994a2><h2 data-v-022994a2>Multi-band Ditortion Plugin</h2></div><div class="container" data-v-022994a2><h3 data-v-022994a2> Motivation</h3><p data-v-022994a2> I enjoy Bass Music like Dubstep. This genre usually requires a lot of distortion to boost energy to create aggressive feels. I think it is interesting to build a distortion that can apply different types of distortion on different frequency domain since this type of distortion is not common in the market. Thereforem, through this project, I want to make a more flexible and versatile distortion to distort audio in more possibilities. </p><h3 data-v-022994a2> Plugin Design</h3><p data-v-022994a2> My plugin is called IIIONSTER(Monster). I changed “M” into “III” because I want to represent that it is a 3 band distortion which divided the input signal into low(20-200hz), middle(200-2khz) and high frequencies(2khz-20khz), and each of the band can apply different distortion type(totally 3 types). This is my flow diagram which describe how my plugin is constructed: </p><div class="images" data-v-022994a2><img src="'+o+'" alt="Flowdiagram" class="prototype-image" data-v-022994a2></div><p data-v-022994a2> One key element in my plugin is that I utilized Linkwitz-Riley filters to perform multi-band separation. I did some research on FIR filter implementation and found it would be hard to create a perfect brick wall shape filter. Then, I found the Linkwitz-Riley filter being employed on some multi-band compressors and speakers and found its characteristics very suitable for my plugin. Luckily the Juce has Linkwitz-Riley in the dsp library. Therefore, I used 4 Linkwitz-Riley filters. One is for low pass one is for high pass and I used another one lowpass filter and high pass filter to form the bandpass filter in the middle frequency range. Below is code of separating signal by applying filters. </p><div class="images" data-v-022994a2><img src="'+s+'" alt="Signal" class="prototype-image" data-v-022994a2></div><p data-v-022994a2> I set the cross over point at 200hz and 2khz where those four Linkewirz-riley filters cross with each other at these two points. These two points are common under speaker usage, so I took these two points and band boundary. The advantage of using Linkwitz-Riley filter is that it ensures four filters’ sum produce a flat amplitude response which let the division of three bands adding together sound the same as the original input, so I can maintain the original nature of sounds before distortion after splitting to 3 bands. For each of the band it has an independent drive parameter that can control the gain before distortion. The range of parameters is from -36 db to 36 db. </p><div class="images" data-v-022994a2><img src="'+n+'" alt="Lindley" class="prototype-image" data-v-022994a2></div><p data-v-022994a2> For the distortion algorithm, I have 3 types of distortion algorithm which are Arctan algorithm, Hard clipping algorithm, and Soft clipping algorithm. I named them correspondingly in medium, hard and soft in my plugin. Below is the figure explaining the three distortion in math functions </p><div class="images" data-v-022994a2><img src="'+r+'" alt="Distortionalgo" class="prototype-image" data-v-022994a2></div><p data-v-022994a2> When I apply these math on my code, I create a structure called DistortionType, then write the function called applyDistortion. Once the Distortion Type is selected and passed in processing block, it will call the function below which first match the distortiontype and then use the corresponding math function on the input. </p><div class="images" data-v-022994a2><img src="'+l+'" alt="Code" class="prototype-image" data-v-022994a2></div><p data-v-022994a2> Other filters: I also have a High Pass filter before the distortion chain which allow people to first filter out the unwanted low frequencies. This filter is just a normal hp filter with q factor of 3. People can adjust cutoff from 20hz to 1khz. I also have another peak filter before distortion chain, this is a peak filter with Q= 8 and gain of 6db, this allows user to boost a small range of frequency to add tonality to the distortion. People can adjust cutoff from 1khz to 10khz. Finally I also used a low pass filter after distortion chain because distortion in high frequency often produce unwanted frequencies that is harmful to ear. Therefore, I used a low pass filter of q of 3 to filter out the noisy frequencies. People can adjust cut off from 1khz to 20khz. </p><p data-v-022994a2> Mix and Output: The Mix parameter is just the mix of wet and dry signal from 0 percent to 100 percent. The output is the parameter control the gain after all process chain which people can adjust from -24 db to 6 db. </p><p data-v-022994a2> Random: I also designed a random function. By clicking the button, the random generator will generate values for each parameter and set those parameter as the random number. I particularly set the range of random generated value to make sure that the value is always applicable to the corresponding parameter. Having a random button can give some inspiration for users when they have no idea of adjusting parameters. </p><h3 data-v-022994a2>GUI design</h3><div class="images" data-v-022994a2><img src="'+d+'" alt="Gui" class="prototype-image" data-v-022994a2></div><p data-v-022994a2> To make plugin looks more usable and less raw to users, I spent quite amount of time designing GUI. I intended to design a minimalism GUI which can make people know my plugin clearly just through GUI. I chose black and white as main color because it is simple and effective when people see the GUI. I particularly used LookandFeelV4 class in the JUCE. I created my own header file called CustomiLook andFeel. In the file, specifically the picture below, I customized the the rotary slider by drawing a circle with a small rectangular as the tick pointing to the rotary angle. In addition, I customized the vertical slider looking by drawing a black rectangular with a wider but smaller white rectangular thumb. </p><p data-v-022994a2> To maintain the uniform look of GUI, I set the textbox’s background to white and outline as transparent. In addition, I set the combo box’ text color, background color and check label color as well. I divided my plugin into four sections by drawing rectangles. The section without rectangle boundary is obvious the Title section which notify people what the plugin is called. Then, the first section is distortion section which contains all distortion related parameters. The second section is the control section which contains the output and mix that is responsible for the overall signal flow after processing. The third section is tonality control section which control filters that can shape the tones of the sound and a random button. As usual, I still used the double-click-to-return-default function on all parameters which allow users to reset the parameter to initial states. I think this would help a lot when people what to reset the parameters. </p><p data-v-022994a2> At last, I observed that once I closed the plugin and reopen it, the combo box will automatically return to the default setting. To prevent that the setting is not usable once user closed the window of gui and just open it again, I found that using xml to store data and set the combo box selection in the processor through getState and setStateinformation function. By doing so, the plugin will remember the combo box choice once user close the window and reopen it. </p><h3 data-v-022994a2> Future Improvement </h3><p data-v-022994a2> Currently, the plugin have 2 most obvious problem that could be improved in the future. 1. When the mix of wet and dry signal is 50 percent, the sound does not sum up to be flat at two cross point of Linkwitz-Riley filters. At the frequency of 200 hz and 2khz, there are two small down curve which result in less level in these two frequency. Since the Linkwitz-Riley should ensure the sum to be plat, I think it may be the phase cancellation of dry signal and wet signal. The filtered signal may have some subtle changes in phase since filter actually has delay. The solution may be improving the Linkwitz-Riley filter design to see if can eliminate the problem. Another possibility is to look into designing FIR filter to replace Linkwitz-Riley in the future to see if it performs better. 2.The GUI label alignment and pop up menu color of combo box. The GUI label and texts are all aligned in hard code right now, so it is not strictly aligned. In the future it may be improved by using layout setting to write a more uniform looking. In addition, once users click the combo box, the pop up menu’s color is still default color, so there may be a way to modify this in the future. Lastly, other distortion types could be considered in the future like overdrive and fuzz which could increase the possibilities of the plugin. </p><h3 data-v-022994a2>Audio Example</h3><p data-v-022994a2> For my distortion in music content, I applied my distortion to the piano, synth bass, electric bass and guitars. For piano and bass, they mostly contribute to the low frequency domain. I want to boost low frequency to give a warm feeling but not distorting too hard and making low frequency too blurry, so I distorted lower band about 6db in med type. For guitar, I added several different types of distortion. For the quarter notes playing at mid low frequency, I distorted with about 18 db in both mid and low band, and set the mid band to hard since I want it to be more distorted. For the higher pitch riff guitar, I distorted it with mid and high band at about 20 db. Then, I use my low pass filter to filter out some unwanted high frequency For the drum I distorted both snare and kick. For snare, I mainly distort the mid range about 18 db and set tone to around 200hz to emphasize the snare’s strong metallic hit. Then I distorted kick with low band and mid band. I distorted the mid band with hard mode and more than low band since I think the low band for kick is enough and I want to use mid band to boost the punch feels of the kick. With all these distortion and the reverb and compressor only, I transfer my music before distortion(left) to music after distortion(right). </p><audio controls data-v-022994a2><source src="'+h+'" type="audio/mpeg" data-v-022994a2> Your browser does not support the audio element. </audio><audio controls data-v-022994a2><source src="'+c+'" type="audio/mpeg" data-v-022994a2> Your browser does not support the audio element. </audio></div>',2);function p(e,t,a,i,o,s){return u}var m={name:"Project3View"},f=a(1241);const g=(0,f.A)(m,[["render",p],["__scopeId","data-v-022994a2"]]);var v=g},8052:function(e,t,a){a.r(t),a.d(t,{default:function(){return x}});var i=a(6768),o=a.p+"img/prototype1.60630985.png",s=a.p+"img/prototype2.be536919.png",n=a.p+"img/overview1.04e1ffb5.png",r=a.p+"img/overview2.76bd4637.png",l=a.p+"img/overview3.2e54b783.png",d=a.p+"img/feature1.b6060d7e.png",h=a.p+"img/feature2.b1a094ff.png",c=a.p+"img/feature3.8f9bc529.png",u=a.p+"img/feature4.64347c91.png",p=a.p+"img/feature5.d09f4a7f.png";const m=e=>((0,i.Qi)("data-v-2fee7e6f"),e=e(),(0,i.jt)(),e),f=m((()=>(0,i.Lk)("div",null,[(0,i.Lk)("h2",null,"Gamebox FM bass synthesizer")],-1))),g=m((()=>(0,i.Lk)("div",{class:"container"},[(0,i.Lk)("h3",null," Introduction "),(0,i.Lk)("div",{class:"images"},[(0,i.Lk)("img",{src:o,alt:"Prototype 1",class:"prototype-image"}),(0,i.Lk)("img",{src:s,alt:"Prototype 2",class:"prototype-image"})]),(0,i.Lk)("p",null," This project is called Gamebox FM bass synthesizer. It is an instrument inspired by the form of game joystick controller and classical 8 bit sound. Ideally player can play this instrument like game controller which give people fun. The basic sound is the low resolution simple wave-shape sound like sine, saw, square and triangle. To make it low resolution, I built the bit crusher which can be modified from 1 bit to 16 bits. I also added the FM synthesis to increase the complexity of the sound. The soundscape of the instrument is basically bass sound which you can play a single shot of bass or consecutive bass. I specifically set the range from C1 to A2 which is really low. In addition, since I added reverb, it can also generate low atmospheric sound. An interesting design I made is I left a slide space for the button where you can dismount the button and slide it to a position you want and mount it again. This help to better for people having different hands size to better hold it. Here is the video of my prototype. ")],-1))),v=m((()=>(0,i.Lk)("div",null,[(0,i.Lk)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/qht6DBH1G4w?si=hWoycw5UF8TZGD0Z",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",referrerpolicy:"strict-origin-when-cross-origin",allowfullscreen:""})],-1))),b=(0,i.Fv)('<div class="container" data-v-2fee7e6f><h3 data-v-2fee7e6f> Control and Mapping of parameters </h3><div class="images" data-v-2fee7e6f><img src="'+n+'" alt="Overview 1" class="prototype-image" data-v-2fee7e6f></div><p data-v-2fee7e6f> The instrument consists of 1 knob, 2 joysticks, 2 buttons and a accelerometer as above lay out. Each Joysticks has 3 controls, the X axis, Y axis, and Z axis. The Z axis of the joysticks has the same function as the button. For the accelerometer, I only used the X axis and Y axis </p><div class="images" data-v-2fee7e6f><img src="'+r+'" alt="Overview 2" class="prototype-image" data-v-2fee7e6f></div><p data-v-2fee7e6f> Knob: control the Volume and ADSR of Sound. I set the default as volume control. For the volume, it ranges from 0 to 1. For Attack, it ranges from 0 to 3000ms. For Decay, it ranges from 50ms to 5000ms. For Sustain, it range from 0 to 1, any non zero value represents the having sustain with button is pressed. For Release, it ranges from 0 ms to 3000ms. </p><p data-v-2fee7e6f> Joystick1 X axis :control the bit depth of the sound. The default value at middle is 8 bit. When the joystick moves towards left, the value decrease until 1 bit, when joystick moves towards right, the bit depth can increase up to 16 bits </p><p data-v-2fee7e6f> Joystick1 Y axis :control the FM modulation index. The default index is 0. I set the range of index from 0 to 0.5. Only downward movement can increase the value up to 0.5. Moving upward will not have any effect. </p><p data-v-2fee7e6f> Joystick1 Z axis :switch the knob control from Volume, Attack, Decay, Sustain, Release. Each time pressing down the joystick 1, player can switch between different parameters controlled by knob in sequence. </p><p data-v-2fee7e6f> Joystick2 X axis :control the metro frequency. The metro frequency mainlt conrtol how fast the consecutive bass is. It is set default as 500ms, moving left can decrease to 50ms, and moving right increase to up to 1000ms. In bpm, it ranges from 60 bpm to 1200bpm and default as 120bpm. </p><p data-v-2fee7e6f> Joystick2 Y axis :control the Frequency of pitch. It has range from 32.703 hz(C1) to 110hz(A2). Moving joystick upward decreases the frequency and moving it downwards increases the frequency. </p><p data-v-2fee7e6f> Joystick2 Z axis :switch the waveshape from sine, to saw, square, or triangle </p><p data-v-2fee7e6f> Button1: trigger the 1 time sound </p><p data-v-2fee7e6f> Button2: trigger the consistent sound controlled by metro frequency </p><div class="images" data-v-2fee7e6f><img src="'+l+'" alt="Overview 3" class="prototype-image" data-v-2fee7e6f></div><p data-v-2fee7e6f> Rotation around X axis: control the reverb internal feedback percentage which has the range from 0 to 100. More degrees in rotation means larger the feedback and longer decay. It can be 90 degree at most. Since I took the absolute value of the X axis from accelerometer, rotate in both clockwise and counter-clockwise directions have same effect. Rotation around Y axis: control the noise mix. Just like X axis, rotate in both clockwise and counter-clockwise directions have same effect. The more degree you rotate, the larger volume noise has. The volume range of noise is from 0 to 1. Overall, my mapping of hardware and parameters are basically one-to-one mapping since I want it to be clear for user to adjust each parameter independently to shape their sound. The special mapping is that the knob and joystick1 Z axis map to multiple parameters. It seems to be 2 to more mapping but essentially it is also one-to-one since the switch is a function and I mapped the function to joystick1 Z axis. </p><h3 data-v-2fee7e6f> Key features explanation </h3><h4 data-v-2fee7e6f>Bit crush</h4><div class="images" data-v-2fee7e6f><img src="'+d+'" alt="Feature 1" class="prototype-image" data-v-2fee7e6f></div><p data-v-2fee7e6f> The bit crush is one of the main inspirations of this instrument. Here is how I implemented it. I take the input from oscillator and a number represents target bit. The expression pow(2, $f1) - 1 calculates the maximum amplitude level for the given bit depth.The expression (1 / $f1) computes the resolution based on the bit depth. In the end, the bit crush is represented by this equation Output=round(Resolution/Input)×Resolution which is expr~ round($v1/$f2). This expression divides the incoming signal value by the resolution (step size) and rounds it to the nearest integer. This process quantizes the signal, reducing its resolution to simulate lower bit depth. </p><h4 data-v-2fee7e6f>FM synthesis </h4><div class="images" data-v-2fee7e6f><img src="'+h+'" alt="Feature 2" class="prototype-image" data-v-2fee7e6f></div><p data-v-2fee7e6f> For the FM synthesis in this instrument, I have 1 carrier and 1 modulator. The carrier has 4 waveshapes which are changeable but the modulator is just a oscillator with sine wave. I set the frequency of carrier and modulator the same so that it can have clear pitch with FM synthesis. I modulate the Mod index by using the joystick1 Y axis. </p><h4 data-v-2fee7e6f>Moses to set stable default and limit value</h4><div class="images" data-v-2fee7e6f><img src="'+c+'" alt="Feature 3" class="prototype-image" data-v-2fee7e6f></div><p data-v-2fee7e6f> When I experiment with my joystick and accelerometer, I found that the value of these sensors are always varying with small amount. Since, I want the default state which is not moving joystick and accelerometer to be a stable default value, I used the moses object which is essentially logic of if small do something, else do other things. Therefore, I set the moses value as a small range that the default state would likely to be. In addition, I found that the max/ min value of the sensor will change, I also applied moses at the limit to set up the lower bound and higher bound value of that parameter could reach </p><h4 data-v-2fee7e6f>Switch between parameters</h4><div class="images" data-v-2fee7e6f><img src="'+u+'" alt="Feature 4" class="prototype-image" data-v-2fee7e6f></div><p data-v-2fee7e6f> For switching parameters, once pressed the button, it will select from 5 options. Each option will send 1 to its representing spigot and send 0 to all other option. The spigot is essentially the gate to let the data pass through. Therefore, by doing so in the graph, I can switch the parameter control between 5 options. </p><h4 data-v-2fee7e6f>Rotation with accelerometer</h4><div class="images" data-v-2fee7e6f><img src="'+p+'" alt="Feature 5" class="prototype-image" data-v-2fee7e6f></div><p data-v-2fee7e6f> For accelerometer calculation, I just did in the default way which is angle theta = atan2(sin(theta), cos(theta)), and then times 0.3183 to scale within -1 to 1. However, a trick I did here is to take absolute value of the theta which makes rotation in both clockwise and counter-clockwise the same value. Therefore, people can play in preference they want and have the same effect. </p><h3 data-v-2fee7e6f>Possible Future Improvement </h3><p data-v-2fee7e6f> One point is that I could improve on the precision and stability of the operation like pitch or other index. Since I am using the joysticks, it is very hard to keep the value at the same exact amount. Therefore, sometimes, the sound came out is not stable. A slight change may cause large variation in the sound, so improving the precision is important. About the instrument’s hardware, I think design a better case is also important. Current case to suit bela and breadborad is kind of big which making it hard for people to hold if their hands are small. Shrinking the size of the case and make it more comfortable and ergonomic could be a great improvement since it will be more like a real game controller. In addition, the 3d printing material is also fragile, I need to thicken parts that pressing occurs or it will break easily. </p></div>',1);function y(e,t,a,o,s,n){return(0,i.uX)(),(0,i.CE)(i.FK,null,[f,g,v,b],64)}var w={name:"YouTubeEmbed"},k=a(1241);const I=(0,k.A)(w,[["render",y],["__scopeId","data-v-2fee7e6f"]]);var x=I}}]);
//# sourceMappingURL=Project3.13877f87.js.map